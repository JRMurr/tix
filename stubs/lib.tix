# =============================================================================
# nixpkgs lib stubs for Tix  (auto-generated from noogle data)
# =============================================================================
#
# Type declarations for nixpkgs library functions.
# Generated by scripts/gen_lib_stubs.py from noogle.dev data.
#
# Embedded into the binary at compile time and loaded by default.
# Use --no-default-stubs to disable, or --stubs to load additional files.
#
# To regenerate:
#   python3 scripts/gen_lib_stubs.py > stubs/lib.tix

# ---------------------------------------------------------------------------
# Top-level types
# ---------------------------------------------------------------------------

type Derivation = {
  name: string,
  system: string,
  builder: path | string,
  args: [string],
  outputs: [string],
  ...
};

# Opaque type representing a set of local files.
type FileSet = { ... };

# Opaque type representing a NixOS option type descriptor (e.g. types.str).
type OptionType = { ... };

# ---------------------------------------------------------------------------
# pkgs module — creates the "Pkgs" type alias
# ---------------------------------------------------------------------------

module pkgs {

  val mkDerivation :: { name: string, ... } -> Derivation;

  val lib :: Lib;

  module stdenv {
    val mkDerivation :: { name: string, ... } -> Derivation;
    val cc :: Derivation;
    val shell :: path;
    val isLinux :: bool;
    val isDarwin :: bool;
    val hostPlatform :: { system: string, isLinux: bool, isDarwin: bool, isx86_64: bool, isAarch64: bool, ... };
  }

  # Fetchers
  val fetchurl :: { url: string, sha256: string, ... } -> Derivation;
  val fetchFromGitHub :: { owner: string, repo: string, rev: string, sha256: string, ... } -> Derivation;
  val fetchgit :: { url: string, rev: string, sha256: string, ... } -> Derivation;

  # Common build tools available in scope
  val runCommand :: string -> { ... } -> string -> Derivation;
  val writeText :: string -> string -> Derivation;
  val writeShellScript :: string -> string -> Derivation;
  val writeShellScriptBin :: string -> string -> Derivation;
  val symlinkJoin :: { name: string, paths: [Derivation], ... } -> Derivation;
  val callPackage :: (a -> Derivation) -> { ... } -> Derivation;
}

# ---------------------------------------------------------------------------
# lib module — creates the "Lib" type alias
# ---------------------------------------------------------------------------

module lib {

  module trivial {
    ## Convert a boolean to a string.
    val boolToString :: bool -> string;
    ## Converts a boolean to a string.
    val boolToYesNo :: bool -> string;
    ## Check if the elements in a list are valid values from a enum, returning
    ## the identity function, or throwing an error message otherwise.
    val checkListOfEnum :: string -> [a] -> [a] -> a -> a;
    ## Concatenate two lists
    val concat :: [a] -> [a] -> [a];
    ## The constant function
    val const :: a -> b -> a;
    ## Flip the order of the arguments of a binary function.
    val flip :: (a -> b -> c) -> (b -> a -> c);
    ## Convert a hexadecimal string to it's integer representation.
    val fromHexString :: string -> int;
    ## Extract the expected function arguments from a function. This works
    ## both with nix-native { a, b ? foo, ... }: style functions and functions
    ## with args set with setFunctionArgs. It has the same retur...
    val functionArgs :: (a -> b) -> { _: bool, ... };
    ## The identity function For when you need a function that does “nothing”.
    val id :: a -> a;
    ## Reads a JSON file.
    val importJSON :: path -> a;
    ## Reads a TOML file.
    val importTOML :: path -> a;
    ## Merge two attribute sets shallowly, right side trumps left
    val mergeAttrs :: { ... } -> { ... } -> { ... };
    ## mirrorFunctionArgs f g creates a new function g' with the same behavior
    ## as g (g' x == g x) but its function arguments mirroring f
    ## (lib.functionArgs g' == lib.functionArgs f).
    val mirrorFunctionArgs :: (a -> b) -> (a -> c) -> (a -> c);
    ## Attempts to return the the current revision of nixpkgs and returns the
    ## supplied default value otherwise.
    val revisionWithDefault :: string -> string;
    ## Add metadata about expected function arguments to a function. The
    ## metadata should match the format given by builtins.functionArgs, i.e. a
    ## set from expected argument to a bool representing whether t...
    val setFunctionArgs :: (a -> b) -> { _: bool, ... } -> (a -> b);
    ## Split type into two subtypes by predicate p, take all elements of the
    ## first subtype to be less than all the elements of the second subtype,
    ## compare elements of a single subtype with yes and no resp...
    val splitByAndCompare :: (a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int);
    ## Like throwIfNot, but negated (throw if the first argument is true).
    val throwIf :: bool -> string -> a -> a;
    ## Like the assert b; e expression, but with a custom error message and
    ## without the semicolon.
    val throwIfNot :: bool -> string -> a -> a;
    ## warn message value
    val warn :: string -> a -> a;
    ## warnIf condition message value
    val warnIf :: bool -> string -> a -> a;
    ## warnIfNot condition message value
    val warnIfNot :: bool -> string -> a -> a;
  }

  module fixedPoints {
    ## Returns the fixpoint that f converges to when called iteratively,
    ## starting with the input x.
    val converge :: (a -> a) -> a -> a;
    ## fix f computes the fixed point of the given function f. In other words,
    ## the return value is x in x = f x.
    val fix :: (a -> a) -> a;
  }

  module attrsets {
    ## Returns an attribute from nested attribute sets.
    val attrByPath :: [string] -> Any -> { ... } -> Any;
    ## Return the names of the attributes in the set set in an alphabetically
    ## sorted list. For instance, builtins.attrNames { y = 1; x = "foo"; }
    ## evaluates to [ "x" "y" ].
    val attrNames :: { ... } -> [string];
    ## Returns the specified attributes from a set.
    val attrVals :: [string] -> { ... } -> [Any];
    ## Returns the values of all attributes in the given set, sorted by
    ## attribute name.
    val attrValues :: { ... } -> [Any];
    ## Return the cartesian product of attribute set value combinations.
    val cartesianProduct :: { ... } -> [{ ... }];
    ## Collect each attribute named attr from a list of attribute sets. Sets
    ## that don't contain the named attribute are ignored.
    val catAttrs :: string -> [{ ... }] -> [Any];
    ## Pick the outputs of packages to place in buildInputs
    val chooseDevOutputs :: [Derivation] -> [Derivation];
    ## Recursively collect sets that verify a given predicate named pred from
    ## the set attrs. The recursion is stopped when the predicate is verified.
    val collect :: ({ ... } -> bool) -> { ... } -> [x];
    ## Map each attribute in the given set and merge them into a new attribute
    ## set.
    val concatMapAttrs :: (string -> a -> { ... }) -> { ... } -> { ... };
    ## Undo the effect of recurseIntoAttrs.
    val dontRecurseIntoAttrs :: { ... } -> { ... };
    ## Filter an attribute set by removing all attributes for which the given
    ## predicate return false.
    val filterAttrs :: (string -> Any -> bool) -> { ... } -> { ... };
    ## Filter an attribute set recursively by removing all attributes for
    ## which the given predicate return false.
    val filterAttrsRecursive :: (string -> Any -> bool) -> { ... } -> { ... };
    ## Apply fold functions to values grouped by key.
    val foldAttrs :: (Any -> Any -> Any) -> Any -> [{ ... }] -> Any;
    ## Like lib.lists.foldl' but for attribute sets. Iterates over every name-
    ## value pair in the given attribute set. The result of the callback
    ## function is often called acc for accumulator. It is passed b...
    val foldlAttrs :: ( a -> string -> b -> a ) -> a -> { _: b, ... } -> a;
    ## Generate an attribute set by mapping a function over a list of
    ## attribute names.
    val genAttrs :: [ string ] -> (string -> Any) -> { ... };
    ## getAttr returns the attribute named s from set. Evaluation aborts if
    ## the attribute doesn’t exist. This is a dynamic version of the .
    ## operator, since s is an expression rather than an identifier.
    val getAttr :: string -> { _: a, ... } -> a;
    ## Like attrByPath, but without a default value. If it doesn't find the
    ## path it will throw an error.
    val getAttrFromPath :: [string] -> { ... } -> Any;
    ## Given a set of attribute names, return the set of the corresponding
    ## attributes from the given set.
    val getAttrs :: [string] -> { ... } -> { ... };
    ## Get a package's bin output. If the output does not exist, fallback to
    ## .out and then to the default.
    val getBin :: Derivation -> Derivation;
    ## Get a package's dev output. If the output does not exist, fallback to
    ## .out and then to the default.
    val getDev :: Derivation -> Derivation;
    ## Get the first of the outputs provided by the package, or the default.
    ## This function is aligned with _overrideFirst() from the multiple-
    ## outputs.sh setup hook. Like getOutput, the function is idempot...
    val getFirstOutput :: [string] -> Derivation -> Derivation;
    ## Get a package's include output. If the output does not exist, fallback
    ## to .dev, then to .out, and then to the default.
    val getInclude :: Derivation -> Derivation;
    ## Get a package's lib output. If the output does not exist, fallback to
    ## .out and then to the default.
    val getLib :: Derivation -> Derivation;
    ## Get a package's man output. If the output does not exist, fallback to
    ## .out and then to the default.
    val getMan :: Derivation -> Derivation;
    ## Get a package's static output. If the output does not exist, fallback
    ## to .lib, then to .out, and then to the default.
    val getStatic :: Derivation -> Derivation;
    ## hasAttr returns true if set has an attribute named s, and false
    ## otherwise. This is a dynamic version of the ? operator, since s is an
    ## expression rather than an identifier.
    val hasAttr :: string -> { ... } -> bool;
    ## Returns if an attribute from nested attribute set exists.
    val hasAttrByPath :: [string] -> { ... } -> bool;
    ## Return true if e evaluates to a set, and false otherwise.
    val isAttrs :: a -> bool;
    ## Check whether the argument is a derivation. Any set with { type =
    ## "derivation"; } counts as a derivation.
    val isDerivation :: Any -> bool;
    ## Construct a set from a list specifying the names and values of each
    ## attribute. Each element of the list should be a set consisting of a
    ## string-valued attribute name specifying the name of the attri...
    val listToAttrs :: [{ name: string, value: a }] -> { _: a, ... };
    ## Returns the longest prefix of an attribute path that refers to an
    ## existing attribute in a nesting of attribute sets.
    val longestValidPathPrefix :: [string] -> a -> [string];
    ## Apply a function to each element in an attribute set, creating a new
    ## attribute set.
    val mapAttrs :: (string -> Any -> Any) -> { ... } -> { ... };
    ## Like mapAttrs, except that it recursively applies itself to the leaf
    ## attributes of a potentially-nested attribute set: the second argument
    ## of the function will never be an attrset. Also, the first ...
    val mapAttrsRecursive :: ([string] -> a -> b) -> { ... } -> { ... };
    ## Like mapAttrsRecursive, but it takes an additional predicate that tells
    ## it whether to recurse into an attribute set. If the predicate returns
    ## false, mapAttrsRecursiveCond does not recurse, but inst...
    val mapAttrsRecursiveCond :: ({ ... } -> bool) -> ([string] -> a -> b) -> { ... } -> { ... };
    ## Call a function for each attribute in the given set and return the
    ## result in a list.
    val mapAttrsToList :: (string -> a -> b) -> { ... } -> [b];
    ## Apply a function to each leaf (non‐attribute‐set attribute) of a tree
    ## of nested attribute sets, returning the results of the function as a
    ## list, ordered lexicographically by their attribute paths.
    val mapAttrsToListRecursive :: ([string] -> a -> b) -> { ... } -> [b];
    ## Determine the nodes of a tree of nested attribute sets by applying a
    ## predicate, then apply a function to the leaves, returning the results
    ## as a list, ordered lexicographically by their attribute pa...
    val mapAttrsToListRecursiveCond :: ([string] -> { ... } -> bool) -> ([string] -> a -> b) -> { ... } -> [b];
    ## Return the result of function f applied to the cartesian product of
    ## attribute set value combinations. Equivalent to using cartesianProduct
    ## followed by map.
    val mapCartesianProduct :: ({ ... } -> a) -> { ... } -> [a];
    ## Recurse into every attribute set of the first argument and check that:
    ## - Each attribute path also exists in the second argument. - If the
    ## attribute's value is not a nested attribute set, it must ha...
    val matchAttrs :: { ... } -> { ... } -> bool;
    ## Merge a list of attribute sets together using the // operator. In case
    ## of duplicate attributes, values from later list elements take
    ## precedence over earlier ones. The result is the same as foldl me...
    val mergeAttrsList :: [ { ... } ] -> { ... };
    ## If cond is true, return the attribute set as, otherwise an empty
    ## attribute set.
    val optionalAttrs :: bool -> { ... } -> { ... };
    ## Override only the attributes that are already present in the old set
    ## useful for deep-overriding.
    val overrideExisting :: { ... } -> { ... } -> { ... };
    ## Make various Nix tools consider the contents of the resulting attribute
    ## set when looking for what to build, find, etc.
    val recurseIntoAttrs :: { ... } -> { ... };
    ## A recursive variant of the update operator //. The recursion stops when
    ## one of the attribute values is not an attribute set, in which case the
    ## right hand side value takes precedence over the left h...
    val recursiveUpdate :: { ... } -> { ... } -> { ... };
    ## Update lhs so that rhs wins for any given attribute path that occurs in
    ## both.
    val recursiveUpdateUntil :: ( [ string ] -> { ... } -> { ... } -> bool ) -> { ... } -> { ... } -> { ... };
    ## Create a new attribute set with value set at the nested attribute
    ## location specified in attrPath.
    val setAttrByPath :: [string] -> Any -> { ... };
    ## Turns a list of strings into a human-readable description of those
    ## strings represented as an attribute path. The result of this function
    ## is not intended to be machine-readable. Create a new attribu...
    val showAttrPath :: [string] -> string;
    ## Converts a store path to a fake derivation.
    val toDerivation :: path -> Derivation;
    ## unionOfDisjoint x y is equal to x // y, but accessing attributes
    ## present in both x and y will throw an error. This operator is
    ## commutative, unlike //.
    val unionOfDisjoint :: { ... } -> { ... } -> { ... };
    ## Merge sets of attributes and combine each attribute value in to a list.
    val zipAttrs :: [ { ... } ] -> { ... };
    ## Merge sets of attributes and use the function f to merge attribute
    ## values. Like lib.attrsets.zipAttrsWithNames with all key names are
    ## passed for names.
    val zipAttrsWith :: (string -> [ Any ] -> Any) -> [ { ... } ] -> { ... };
    ## Merge sets of attributes and use the function f to merge attributes
    ## values.
    val zipAttrsWithNames :: [ string ] -> (string -> [ Any ] -> Any) -> [ { ... } ] -> { ... };
  }

  module lists {
    ## Returns true if function pred returns true for all elements of list.
    val all :: (a -> bool) -> [a] -> bool;
    ## Check if list contains only unique elements. O(n^2) complexity.
    val allUnique :: [a] -> bool;
    ## Returns true if function pred returns true for at least one element of
    ## list.
    val any :: (a -> bool) -> [a] -> bool;
    ## The common prefix of two lists.
    val commonPrefix :: [a] -> [a] -> [a];
    ## Compare two lists element-by-element with a comparison function cmp.
    val compareLists :: (a -> a -> int) -> [a] -> [a] -> int;
    ## Concatenate a list of lists into a single list.
    val concatLists :: [[a]] -> [a];
    ## Map and concatenate the result.
    val concatMap :: (a -> [b]) -> [a] -> [b];
    ## Count how many elements of list match the supplied predicate function.
    val count :: (a -> bool) -> [a] -> int;
    ## Returns the image of the cross product of some lists by a function.
    val crossLists :: (a -> b -> c) -> [a] -> [b] -> [c];
    ## Remove the first (at most) N elements of a list.
    val drop :: int -> [a] -> [a];
    ## Remove the last (at most) N elements of a list.
    val dropEnd :: int -> [a] -> [a];
    ## Return true if a value equal to x occurs in the list xs, and false
    ## otherwise.
    val elem :: a -> [a] -> bool;
    ## Return a list consisting of the elements of list for which the function
    ## f returns true.
    val filter :: (a -> bool) -> [a] -> [a];
    ## Find the first element in the list matching the specified predicate or
    ## return default if no such element exists.
    val findFirst :: (a -> bool) -> b -> [a] -> (a | b);
    ## Find the first index in the list matching the specified predicate or
    ## return default if no such element exists.
    val findFirstIndex :: (a -> bool) -> b -> [a] -> (int | b);
    ## Find the sole element in the list matching the specified predicate.
    val findSingle :: (a -> bool) -> a -> a -> [a] -> a;
    ## Flatten the argument into a single list; that is, nested lists are
    ## spliced into the top-level lists.
    val flatten :: [[a]] -> [a];
    ## “left fold”, like foldr, but from the left:
    val foldl :: (b -> a -> b) -> b -> [a] -> b;
    ## “right fold” a binary function op between successive elements of list
    ## with nul as the starting value, i.e., foldr op nul [x_1 x_2 ... x_n] ==
    ## op x_1 (op x_2 ... (op x_n nul)).
    val foldr :: (a -> b -> b) -> b -> [a] -> b;
    ## Apply the function to each element in the list. Same as map, but
    ## arguments flipped.
    val forEach :: [a] -> (a -> b) -> [b];
    ## Groups elements of list together by the string returned from the
    ## function f called on each element. It returns an attribute set where
    ## each attribute value contains the elements of list that are map...
    val groupBy :: (a -> string) -> [a] -> { _: [a], ... };
    ## Whether the first list is a prefix of the second list.
    val hasPrefix :: [a] -> [a] -> bool;
    ## Return the first element of a list; abort evaluation if the argument
    ## isn’t a list or is an empty list. You can test whether a list is empty
    ## by comparing it with [].
    val head :: [a] -> a;
    ## Filter a list for elements that satisfy a predicate function. The
    ## predicate function is called with both the index and value for each
    ## element. It must return true/false to include/exclude a given e...
    val ifilter0 :: (int -> a -> bool) -> [a] -> [a];
    ## Map with index starting from 0
    val imap0 :: (int -> a -> b) -> [a] -> [b];
    ## Map with index starting from 1
    val imap1 :: (int -> a -> b) -> [a] -> [b];
    ## Returns all elements but the last.
    val init :: [a] -> [a];
    ## Intersects list list1 and another list (list2).
    val intersectLists :: [a] -> [a] -> [a];
    ## Returns the last element of a list.
    val last :: [a] -> a;
    ## Return the length of the list e.
    val length :: [a] -> int;
    ## Apply the function f to each element in the list list. For example,
    val map :: (a -> b) -> [a] -> [b];
    ## Test if two lists have no common element. It should be slightly more
    ## efficient than intersectLists a b == [].
    val mutuallyExclusive :: [a] -> [a] -> bool;
    ## Sort list using "Natural sorting". Numeric portions of strings are
    ## sorted in numeric order.
    val naturalSort :: [string] -> [string];
    ## Return a singleton list or an empty list, depending on a boolean value.
    ## Useful when building lists with optional elements (e.g. ++ optional
    ## (system == "i686-linux") firefox).
    val optional :: bool -> a -> [a];
    ## Returns a list or an empty list, depending on a boolean value.
    val optionals :: bool -> [a] -> [a];
    ## Returns a list of integers from first up to and including last.
    val range :: int -> int -> [int];
    ## Remove elements equal to e from a list. Useful for buildInputs.
    val remove :: a -> [a] -> [a];
    ## Remove the first list as a prefix from the second list. Error if the
    ## first list isn't a prefix of the second list.
    val removePrefix :: [a] -> [a] -> [a];
    ## Returns a list with n copies of an element.
    val replicate :: int -> a -> [a];
    ## Reverse the order of the elements of a list.
    val reverseList :: [a] -> [a];
    ## Create a list consisting of a single element. singleton x is sometimes
    ## more convenient with respect to indentation than [x] when x spans
    ## multiple lines.
    val singleton :: a -> [a];
    ## Sort a list based on a comparator function which compares two elements
    ## and returns true if the first argument is strictly below the second
    ## argument. The returned list is sorted in an increasing ord...
    val sort :: (a -> a -> bool) -> [a] -> [a];
    ## Returns a list consisting of at most count elements of list, starting
    ## at index start.
    val sublist :: int -> int -> [a] -> [a];
    ## Subtracts list e from another list (list2).
    val subtractLists :: [a] -> [a] -> [a];
    ## Return the list without its first item; abort evaluation if the
    ## argument isn’t a list or is an empty list.
    val tail :: [a] -> [a];
    ## Returns the first (at most) N elements of a list.
    val take :: int -> [a] -> [a];
    ## Returns the last (at most) N elements of a list.
    val takeEnd :: int -> [a] -> [a];
    ## Remove duplicate elements from the list. O(n^2) complexity.
    val unique :: [a] -> [a];
    ## Removes duplicate strings from the list. O(n log n) complexity.
    val uniqueStrings :: [ string ] -> [ string ];
    ## Merges two lists of the same size together. If the sizes aren't the
    ## same the merging stops at the shortest. How both lists are merged is
    ## defined by the first argument.
    val zipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c];
  }

  module strings {
    ## Appends string context from string like object src to target.
    val addContextFrom :: string -> string -> string;
    ## Convert char to ascii value, must be in printable range
    val charToInt :: string -> int;
    ## Create a "-D<condition>={TRUE,FALSE}" string that can be passed to
    ## typical CMake invocations.
    val cmakeBool :: string -> bool -> string;
    ## Create a "-D<feature>:STRING=<value>" string that can be passed to
    ## typical CMake invocations. This is the most typical usage, so it
    ## deserves a special case.
    val cmakeFeature :: string -> string -> string;
    ## Create a "-D<feature>:<type>=<value>" string that can be passed to
    ## typical CMake invocations.
    val cmakeOptionType :: string -> string -> string -> string;
    ## Returns the length of the prefix that appears in both strings a and b.
    val commonPrefixLength :: string -> string -> int;
    ## Returns the length of the suffix common to both strings a and b.
    val commonSuffixLength :: string -> string -> int;
    ## Like concatMapStrings except that the function f also gets the position
    ## as a parameter.
    val concatImapStrings :: (int -> a -> string) -> [a] -> string;
    ## Same as concatMapStringsSep, but the mapping function additionally
    ## receives the position of its argument.
    val concatImapStringsSep :: string -> (int -> a -> string) -> [a] -> string;
    ## Concatenate a list of strings, adding a newline at the end of each one.
    ## Defined as concatMapStrings (s: s + "\n").
    val concatLines :: [string] -> string;
    ## Like concatMapStringsSep but takes an attribute set instead of a list.
    val concatMapAttrsStringSep :: string -> (string -> Any -> string) -> { ... } -> string;
    ## Map a function over a list and concatenate the resulting strings.
    val concatMapStrings :: (a -> string) -> [a] -> string;
    ## Maps a function over a list of strings and then concatenates the result
    ## with the specified separator interspersed between elements.
    val concatMapStringsSep :: string -> (a -> string) -> [a] -> string;
    ## Concatenate a list of strings.
    val concatStrings :: [string] -> string;
    ## Concatenate a list of strings with a separator between each element
    val concatStringsSep :: string -> [string] -> string;
    ## Create an "--{enable,disable}-<feature>" string that can be passed to
    ## standard GNU Autoconf scripts.
    val enableFeature :: bool -> string -> string;
    ## Create an "--{enable-<feature>=<value>,disable-<feature>}" string that
    ## can be passed to standard GNU Autoconf scripts.
    val enableFeatureAs :: bool -> string -> string -> string;
    ## Escape occurrence of the elements of list in string by prefixing it
    ## with a backslash.
    val escape :: [string] -> string -> string;
    ## Escape occurrence of the element of list in string by converting to its
    ## ASCII value and prefixing it with \\x. Only works for printable ascii
    ## characters.
    val escapeC :: [string] -> string -> string;
    ## Quotes a string s if it can't be used as an identifier directly.
    val escapeNixIdentifier :: string -> string;
    ## Turn a string s into a Nix expression representing that string
    val escapeNixString :: string -> string;
    ## Turn a string s into an exact regular expression
    val escapeRegex :: string -> string;
    ## Quote string to be used safely within the Bourne shell if it has any
    ## special characters.
    val escapeShellArg :: string -> string;
    ## Quote all arguments that have special characters to be safely passed to
    ## the Bourne shell.
    val escapeShellArgs :: [string] -> string;
    ## Escape the string so it can be safely placed inside a URL query.
    val escapeURL :: string -> string;
    ## Escapes a string s such that it is safe to include verbatim in an XML
    ## document.
    val escapeXML :: string -> string;
    ## Read the contents of a file removing the trailing \n
    val fileContents :: path -> string;
    ## Format a number adding leading zeroes up to fixed width.
    val fixedWidthNumber :: int -> int -> string;
    ## Create a fixed width string with additional prefix to match required
    ## width.
    val fixedWidthString :: int -> string -> string -> string;
    ## Convert a float to a string, but emit a warning when precision is lost
    ## during the conversion
    val floatToString :: float -> string;
    ## This function takes an argument x that's either a derivation or a
    ## derivation's "name" attribute and extracts the name part from that
    ## argument.
    val getName :: string | Derivation -> string;
    ## This function takes an argument x that's either a derivation or a
    ## derivation's "name" attribute and extracts the version part from that
    ## argument.
    val getVersion :: string | Derivation -> string;
    ## Determine whether a string contains the given infix
    val hasInfix :: string -> string -> bool;
    ## Determine whether a string has given prefix.
    val hasPrefix :: string -> string -> bool;
    ## Determine whether a string has given suffix.
    val hasSuffix :: string -> string -> bool;
    ## Place an element between each element of a list
    val intersperse :: a -> [a] -> [a];
    ## Check whether a list or other value x can be passed to toString.
    val isConvertibleWithToString :: a -> bool;
    ## Check whether a value x is a store path.
    val isStorePath :: a -> bool;
    ## Check whether a value can be coerced to a string. The value must be a
    ## string, path, or attribute set.
    val isStringLike :: a -> bool;
    ## Test whether the given name is a valid POSIX shell variable name.
    val isValidPosixName :: string -> bool;
    ## Concatenates a list of strings with a separator between each element.
    val join :: string -> [ string ] -> string;
    ## Computes the Levenshtein distance between two strings a and b.
    val levenshtein :: string -> string -> int;
    ## Returns whether the levenshtein distance between two strings a and b is
    ## at most some value k.
    val levenshteinAtMost :: int -> string -> string -> bool;
    ## Construct a binary search path (such as $PATH) containing the binaries
    ## for a set of packages.
    val makeBinPath :: [Derivation] -> string;
    ## Construct an include search path (such as C_INCLUDE_PATH) containing
    ## the header files for a set of packages or paths.
    val makeIncludePath :: [Derivation] -> string;
    ## Construct a library search path (such as RPATH) containing the
    ## libraries for a set of packages
    val makeLibraryPath :: [Derivation] -> string;
    ## Construct a Unix-style, colon-separated search path consisting of the
    ## given subDir appended to each of the given paths.
    val makeSearchPath :: string -> [string] -> string;
    ## Construct a Unix-style search path by appending the given subDir to the
    ## specified output of each of the packages.
    val makeSearchPathOutput :: string -> string -> [Derivation] -> string;
    ## Create a "-D<condition>={true,false}" string that can be passed to
    ## typical Meson invocations.
    val mesonBool :: string -> bool -> string;
    ## Create a "-D<feature>={enabled,disabled}" string that can be passed to
    ## typical Meson invocations.
    val mesonEnable :: string -> bool -> string;
    ## Create a "-D<feature>=<value>" string that can be passed to typical
    ## Meson invocations.
    val mesonOption :: string -> string -> string;
    ## Extract name and version from a URL as shown in the examples.
    val nameFromURL :: string -> string;
    ## Normalize path, removing extraneous /s
    val normalizePath :: string -> string;
    ## Depending on the boolean cond, return either the given string or the
    ## empty string. Useful to concatenate against a bigger string.
    val optionalString :: bool -> string -> string;
    ## Returns a string without the specified prefix, if the prefix matches.
    val removePrefix :: string -> string -> string;
    ## Returns a string without the specified suffix, if the suffix matches.
    val removeSuffix :: string -> string -> string;
    ## Given string s, replace every occurrence of the string from with the
    ## string to.
    val replaceString :: string -> string -> string -> string;
    ## Given string s, replace every occurrence of the strings in from with
    ## the corresponding string in to.
    val replaceStrings :: [string] -> [string] -> string -> string;
    ## Repeat a string n times, and concatenate the parts into a new string.
    val replicate :: int -> string -> string;
    ## Creates a valid derivation name from a potentially invalid one.
    val sanitizeDerivationName :: string -> string;
    ## Cut a string with a separator and produces a list of strings which were
    ## separated by this separator.
    val splitString :: string -> string -> [string];
    ## Splits a string into substrings based on a predicate that examines
    ## adjacent characters.
    val splitStringBy :: (string -> string -> bool) -> bool -> string -> [string];
    ## Manipulate a string character by character and replace them by strings
    ## before concatenating the results.
    val stringAsChars :: (string -> string) -> string -> string;
    ## Convert a string s to a list of characters (i.e. singleton strings).
    ## This allows you to, e.g., map a function over each character. However,
    ## note that this will likely be horribly inefficient; Nix i...
    val stringToCharacters :: string -> [string];
    ## Converts a string to camelCase. Handles snake_case, PascalCase, kebab-
    ## case strings as well as strings delimited by spaces.
    val toCamelCase :: string -> string;
    ## Parse a string as an int. Does not support parsing of integers with
    ## preceding zero due to ambiguity between zero-padded and octal numbers.
    ## See toIntBase10.
    val toInt :: string -> int;
    ## Parse a string as a base 10 int. This supports parsing of zero-padded
    ## integers.
    val toIntBase10 :: string -> int;
    ## Converts an ASCII string s to lower-case.
    val toLower :: string -> string;
    ## Converts the first character of a string s to upper-case.
    val toSentenceCase :: string -> string;
    ## Converts an ASCII string s to upper-case.
    val toUpper :: string -> string;
    ## Remove leading and trailing whitespace from a string s.
    val trim :: string -> string;
    ## Returns true if string v1 denotes a version equal to or newer than v2.
    val versionAtLeast :: string -> string -> bool;
    ## Returns true if string v1 denotes a version older than v2.
    val versionOlder :: string -> string -> bool;
    ## Create an "--{with,without}-<feature>" string that can be passed to
    ## standard GNU Autoconf scripts.
    val withFeature :: bool -> string -> string;
    ## Create an "--{with-<feature>=<value>,without-<feature>}" string that
    ## can be passed to standard GNU Autoconf scripts.
    val withFeatureAs :: bool -> string -> string -> string;
  }

  module debug {
    ## Conditionally trace the supplied message, based on a predicate.
    val traceIf :: bool -> string -> a -> a;
    ## builtins.trace, but the value is builtins.deepSeqed first.
    val traceSeq :: a -> b -> b;
    ## Like traceSeq, but only evaluate down to depth n. This is very useful
    ## because lots of traceSeq usages lead to an infinite recursion.
    val traceSeqN :: int -> a -> b -> b;
    ## Trace the supplied value and return it.
    val traceVal :: a -> a;
    ## Trace the supplied value after applying a function to it, and return
    ## the original value.
    val traceValFn :: (a -> b) -> a -> a;
  }

  module options {
    ## Extracts values of all file keys of the given list
    val getFiles :: [{ file: a }] -> [a];
    ## Extracts values of all value keys of the given list.
    val getValues :: [{ value: a }] -> [a];
    ## Returns true when the given argument a is an option
    val isOption :: a -> bool;
    ## For use in the defaultText and example option attributes. Causes the
    ## given string to be rendered verbatim in the documentation as Nix code.
    ## This is necessary for complex values, e.g. functions, or ...
    val literalExpression :: string -> { ... };
    ## For use in the defaultText and example option attributes. Causes the
    ## given MD text to be inserted verbatim in the documentation, for when a
    ## literalExpression would be too hard to read.
    val literalMD :: string -> { ... };
    ## "Merge" option definitions by checking that they all have the same
    ## value.
    val mergeEqualOption :: [string] -> [{ file: string, value: a }] -> a;
    ## Require a single definition.
    val mergeOneOption :: [string] -> [{ file: string, value: a }] -> a;
    ## Creates an option declaration with a default value of false, and can be
    ## defined to true.
    val mkEnableOption :: string -> { ... };
    ## Creates an Option declaration for use with the module system.
    val mkOption :: { ... } -> { ... };
    ## Creates an Option attribute set for an option that specifies the
    ## package a module should use for some purpose.
    val mkPackageOption :: { ... } -> (string | [string]) -> { ... } -> { ... };
    ## This option accepts arbitrary definitions, but it does not produce an
    ## option value.
    val mkSinkUndeclaredOptions :: { ... } -> { ... };
    val showDefs :: [{ file: string, value: a }] -> string;
    val showFiles :: [string] -> string;
    ## Convert an option, described as a list of the option parts to a human-
    ## readable version.
    val showOption :: [string] -> string;
  }

  module modules {
    ## See https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-
    ## evalModules or file://./../doc/module-system/module-system.chapter.md
    val evalModules :: { ... } -> { ... };
    ## importApply file arg :: Path -> a -> Module, where import file :: a ->
    ## Module
    val importApply :: path -> a -> { ... };
    val mkAfter :: a -> a;
    ## Like ‘mkRenamedOptionModule’, but doesn't show a warning.
    val mkAliasOptionModule :: [string] -> [string] -> { ... };
    val mkBefore :: a -> a;
    ## Single "from" version of mkMergedOptionModule. Returns a module that
    ## causes a warning to be shown if the "from" option is defined; the
    ## defined value can be used in the "mergeFn" to set the "to" val...
    val mkChangedOptionModule :: [string] -> [string] -> (a -> b) -> { ... };
    val mkDefault :: a -> a;
    ## mkDerivedConfig : Option a -> (a -> Definition b) -> Definition b
    val mkDerivedConfig :: { ... } -> (a -> b) -> b;
    ## The identity function For when you need a function that does “nothing”.
    val mkFixStrictness :: a -> a;
    val mkForce :: a -> a;
    ## Properties.
    val mkIf :: bool -> a -> a;
    val mkImageMediaOverride :: a -> a;
    val mkMerge :: [a] -> a;
    ## Returns a module that causes a warning to be shown if any of the "from"
    ## option is defined; the defined values can be used in the "mergeFn" to
    ## set the "to" value. This function can be used to merge ...
    val mkMergedOptionModule :: [[string]] -> [string] -> ([a] -> b) -> { ... };
    val mkOptionDefault :: a -> a;
    val mkOrder :: int -> a -> a;
    val mkOverride :: int -> a -> a;
    ## Returns a module that causes a warning to be shown if the specified
    ## option is defined. For example,
    val mkRemovedOptionModule :: [string] -> string -> { ... };
    ## Returns a module that causes a warning to be shown if the specified
    ## "from" option is defined; the defined value is however forwarded to the
    ## "to" option. This can be used to rename options while pro...
    val mkRenamedOptionModule :: [string] -> [string] -> { ... };
    val mkVMOverride :: a -> a;
  }

  module customisation {
    ## Call the package function in the file fn with the required arguments
    ## automatically. The function is called with the arguments args, but any
    ## missing arguments are obtained from autoArgs. This functi...
    val callPackageWith :: { ... } -> (({ ... } -> a) | path) -> { ... } -> a;
    ## Like callPackage, but for a function that returns an attribute set of
    ## derivations. The override function is added to the individual
    ## attributes.
    val callPackagesWith :: { ... } -> (({ ... } -> { ... }) | path) -> { ... } -> { ... };
    ## Add attributes to each output of a derivation without changing the
    ## derivation itself and check a given condition when evaluating.
    val extendDerivation :: bool -> Any -> Derivation -> Derivation;
    ## Strip a derivation of all non-essential attributes, returning only
    ## those needed by hydra-eval-jobs. Also strictly evaluate the result to
    ## ensure that there are no thunks kept alive to prevent garbag...
    val hydraJob :: (Derivation | null) -> (Derivation | null);
    ## makeOverridable takes a function from attribute set to attribute set
    ## and injects override attribute which can be used to override arguments
    ## of the function.
    val makeOverridable :: ({ ... } -> a) -> { ... } -> a;
    ## Takes a function and applies it pointwise to each field of a cross
    ## index.
    val mapCrossIndex :: (a -> b) -> { ... } -> { ... };
    ## overrideDerivation drv f takes a derivation (i.e., the result of a call
    ## to the builtin function derivation) and returns a new derivation in
    ## which the attributes of the original are overridden accor...
    val overrideDerivation :: Derivation -> ( Derivation -> { ... } ) -> Derivation;
    ## Removes a prefix from the attribute names of a cross index.
    val renameCrossIndexFrom :: string -> { ... } -> { ... };
    ## Adds a prefix to the attribute names of a cross index.
    val renameCrossIndexTo :: string -> { ... } -> { ... };
  }

  module asserts {
    ## Specialized assertMsg for checking if every one of vals is one of the
    ## elements of the list xs. Useful for checking lists of supported
    ## attributes.
    val assertEachOneOf :: string -> [a] -> [a] -> bool;
    ## Throw if pred is false, else return pred. Intended to be used to
    ## augment asserts with helpful error messages.
    val assertMsg :: bool -> string -> bool;
    ## Specialized assertMsg for checking if val is one of the elements of the
    ## list xs. Useful for checking enums.
    val assertOneOf :: string -> a -> [a] -> bool;
  }

  module fileset {
    ## The file set containing all files from the first file set that are not
    ## in the second file set. See also Difference (set
    ## theory)#Relative_complement).
    val difference :: FileSet -> FileSet -> FileSet;
    ## Create a file set with the same files as a lib.sources-based value.
    ## This does not import any of the files into the store.
    val fromSource :: a -> FileSet;
    ## Create a file set containing all Git-tracked files in a repository.
    val gitTracked :: path -> FileSet;
    ## The file set containing all files that are in both of two given file
    ## sets. See also Intersection (set theory)).
    val intersection :: FileSet -> FileSet -> FileSet;
    ## Tests whether a given value is a fileset, or can be used in place of a
    ## fileset.
    val isFileset :: Any -> bool;
    ## Create a file set from a path that may or may not exist: - If the path
    ## does exist, the path is coerced to a file set. - If the path does not
    ## exist, a file set containing no files is returned.
    val maybeMissing :: path -> FileSet;
    ## The list of file paths contained in the given file set.
    val toList :: FileSet -> [ path ];
    ## Incrementally evaluate and trace a file set in a pretty way. This
    ## function is only intended for debugging purposes. The exact tracing
    ## format is unspecified and may change.
    val trace :: FileSet -> Any -> Any;
    ## Incrementally evaluate and trace a file set in a pretty way. This
    ## function is only intended for debugging purposes. The exact tracing
    ## format is unspecified and may change.
    val traceVal :: FileSet -> FileSet;
    ## The file set containing all files that are in either of two given file
    ## sets. This is the same as unions, but takes just two file sets instead
    ## of a list. See also Union (set theory)).
    val union :: FileSet -> FileSet -> FileSet;
    ## The file set containing all files that are in any of the given file
    ## sets. This is the same as union, but takes a list of file sets instead
    ## of just two. See also Union (set theory)).
    val unions :: [ FileSet ] -> FileSet;
  }

  module filesystem {
    ## A map of all haskell packages defined in the given path, identified by
    ## having a cabal file with the same name as the directory itself.
    val haskellPathsInDir :: path -> { _: path, ... };
    ## Given a directory, return a flattened list of all files within it
    ## recursively.
    val listFilesRecursive :: path -> [ path ];
    ## Whether a path exists and is a directory.
    val pathIsDirectory :: path -> bool;
    ## Whether a path exists and is a regular file, meaning not a symlink or
    ## any other special file type.
    val pathIsRegularFile :: path -> bool;
    ## The type of a path. The path needs to exist and be accessible. The
    ## result is either "directory" for a directory, "regular" for a regular
    ## file, "symlink" for a symlink, or "unknown" for anything else.
    val pathType :: path -> string;
    ## The type of a path. The path needs to exist and be accessible. The
    ## result is either "directory" for a directory, "regular" for a regular
    ## file, "symlink" for a symlink, or "unknown" for anything else.
    val readFileType :: path -> string;
    ## Append /default.nix if the passed path is a directory.
    val resolveDefaultNix :: (path | string) -> (path | string);
  }

  module path {
    ## Append a subpath string to a path.
    val append :: path -> string -> path;
    ## Split a subpath into its path component strings. Throw an error if the
    ## subpath isn't valid. Note that the returned path components are also
    ## valid subpath strings, though they are intentionally not ...
    val components :: string -> [ string ];
    ## Whether the first path is a component-wise prefix of the second path.
    val hasPrefix :: path -> path -> bool;
    ## Whether a path has a store path as a prefix.
    val hasStorePathPrefix :: path -> bool;
    ## Whether a value is a valid subpath string.
    val isValid :: string -> bool;
    ## Join subpath strings together using /, returning a normalised subpath
    ## string.
    val join :: [ string ] -> string;
    ## Normalise a subpath. Throw an error if the subpath isn't valid.
    val normalise :: string -> string;
    ## Remove the first path as a component-wise prefix from the second path.
    ## The result is a normalised subpath string.
    val removePrefix :: path -> path -> string;
  }

  module sources {
    ## Get all files ending with the specified suffices from the given source
    ## directory or its descendants, omitting files that do not match any
    ## suffix. The result of the example below will include files ...
    val sourceFilesBySuffices :: a -> [string] -> a;
    ## Add logging to a source, for troubleshooting the filtering behavior.
    val trace :: a -> a;
  }

  module meta {
    ## Generate CPE parts from inputs. Copies vendor and version to the
    ## output, and sets update to *.
    val cpeFullVersionWithVendor :: string -> string -> { ... };
    ## Generate CPE parts from inputs. Copies vendor to the result. When
    ## version matches X.Y.Z where all parts are numerical, sets version and
    ## update fields to X.Y and Z. Throws an error if the version do...
    val cpePatchVersionInUpdateWithVendor :: string -> string -> { ... };
    ## Get the path to the main program of a package based on meta.mainProgram
    val getExe :: Derivation -> string;
    ## Alternate version of lib.meta.cpePatchVersionInUpdateWithVendor. If
    ## cpePatchVersionInUpdateWithVendor succeeds, returns an attribute set
    ## with success set to true and value set to the result. Otherw...
    val tryCPEPatchVersionInUpdateWithVendor :: string -> string -> { ... };
  }

  module generators {
    ## Mark string as Lua expression to be inlined when processed by toLua.
    val mkLuaInline :: string -> { ... };
    ## Translate a simple Nix expression to Lua representation with occasional
    ## Lua-inlines that can be constructed by mkLuaInline function.
    val toLua :: { ... } -> Any -> string;
  }

  module gvariant {
    ## Check if a value is a GVariant value
    val isGVariant :: Any -> bool;
    ## Returns the GVariant array from the given type of the elements and a
    ## Nix list.
    val mkArray :: [Any] -> a;
    ## Returns the GVariant boolean from the given Nix bool value.
    val mkBoolean :: bool -> a;
    ## Returns the GVariant dictionary entry from the given key and value.
    val mkDictionaryEntry :: string -> Any -> a;
    ## Returns the GVariant double from the given Nix float value.
    val mkDouble :: float -> a;
    ## Returns the GVariant int16 from the given Nix int value.
    val mkInt16 :: int -> a;
    ## Returns the GVariant int32 from the given Nix int value.
    val mkInt32 :: int -> a;
    ## Returns the GVariant int64 from the given Nix int value.
    val mkInt64 :: int -> a;
    ## Returns the GVariant just from the given Nix value.
    val mkJust :: Any -> a;
    ## Returns the GVariant object path from the given Nix string value.
    val mkObjectpath :: string -> a;
    ## Returns the GVariant string from the given Nix string value.
    val mkString :: string -> a;
    ## Returns the GVariant tuple from the given Nix list.
    val mkTuple :: [Any] -> a;
    ## Returns the GVariant uchar from the given Nix int value.
    val mkUchar :: int -> a;
    ## Returns the GVariant uint16 from the given Nix int value.
    val mkUint16 :: int -> a;
    ## Returns the GVariant uint32 from the given Nix int value.
    val mkUint32 :: int -> a;
    ## Returns the GVariant uint64 from the given Nix int value.
    val mkUint64 :: int -> a;
    ## Returns the GVariant value that most closely matches the given Nix
    ## value. If no GVariant value can be found unambiguously then error is
    ## thrown.
    val mkValue :: Any -> a;
    ## Returns the GVariant variant from the given Nix value. Variants are
    ## containers of different GVariant type.
    val mkVariant :: Any -> a;
  }

  module derivations {
    ## Conditionally set a derivation attribute.
    val optionalDrvAttr :: bool -> a -> a | null;
  }

  module network {
    ## Creates an IPv6Address object from an IPv6 address as a string. If the
    ## prefix length is omitted, it defaults to 64. The parser is limited to
    ## the first two versions of IPv6 addresses addressed in RF...
    val fromString :: string -> IPv6Address;
    ## Converts a 48-bit MAC address into a EUI-64 IPv6 address suffix.
    val mkEUI64Suffix :: string -> string;
  }

  module mergeAttrBy {
    ## Concatenate two lists
    val buildInputs :: [a] -> [a] -> [a];
    ## Merge two attribute sets shallowly, right side trumps left
    val cfg :: { ... } -> { ... } -> { ... };
    ## Concatenate two lists
    val configureFlags :: [a] -> [a] -> [a];
    ## Merge two attribute sets shallowly, right side trumps left
    val flags :: { ... } -> { ... } -> { ... };
    ## Merge two attribute sets shallowly, right side trumps left
    val meta :: { ... } -> { ... } -> { ... };
    ## Concatenate two lists
    val nativeBuildInputs :: [a] -> [a] -> [a];
    ## Merge two attribute sets shallowly, right side trumps left
    val passthru :: { ... } -> { ... } -> { ... };
    ## Concatenate two lists
    val patches :: [a] -> [a] -> [a];
    ## Concatenate two lists
    val postAll :: [a] -> [a] -> [a];
    ## Concatenate two lists
    val prePhases :: [a] -> [a] -> [a];
    ## Concatenate two lists
    val propagatedBuildInputs :: [a] -> [a] -> [a];
  }

  module misc {
    ## Concatenate two lists
    val buildInputs :: [a] -> [a] -> [a];
    ## Merge two attribute sets shallowly, right side trumps left
    val cfg :: { ... } -> { ... } -> { ... };
    ## Concatenate two lists
    val configureFlags :: [a] -> [a] -> [a];
    ## Merge two attribute sets shallowly, right side trumps left
    val flags :: { ... } -> { ... } -> { ... };
    ## Map with index starting from 1
    val imap :: (int -> a -> b) -> [a] -> [b];
    ## Merge two attribute sets shallowly, right side trumps left
    val meta :: { ... } -> { ... } -> { ... };
    ## Concatenate two lists
    val nativeBuildInputs :: [a] -> [a] -> [a];
    ## Merge two attribute sets shallowly, right side trumps left
    val passthru :: { ... } -> { ... } -> { ... };
    ## Concatenate two lists
    val patches :: [a] -> [a] -> [a];
    ## Concatenate two lists
    val postAll :: [a] -> [a] -> [a];
    ## Concatenate two lists
    val prePhases :: [a] -> [a] -> [a];
    ## Concatenate two lists
    val propagatedBuildInputs :: [a] -> [a] -> [a];
  }

  module types {
    ## A boolean type (true or false).
    val bool :: OptionType;
    ## A signed integer type.
    val int :: OptionType;
    ## A floating-point number type.
    val float :: OptionType;
    ## An integer or floating-point number type.
    val number :: OptionType;
    ## A string type (single definition only; use lines for merging).
    val str :: OptionType;
    ## A string that must not contain newline characters.
    val singleLineStr :: OptionType;
    ## A string type where multiple definitions are merged with newlines.
    val lines :: OptionType;
    ## A string type where multiple definitions are merged with commas.
    val commas :: OptionType;
    ## A string type where multiple definitions are merged with colons.
    val envVar :: OptionType;
    ## A filesystem path type.
    val path :: OptionType;
    ## A path that must be in the Nix store.
    val pathInStore :: OptionType;
    ## A Nix derivation (package) type.
    val package :: OptionType;
    ## A nixpkgs package set type.
    val pkgs :: OptionType;
    ## A free-form attribute set with no type checking on values.
    val attrs :: OptionType;
    ## Accepts any value; attribute sets are merged recursively.
    val anything :: OptionType;
    ## Accepts any value with no merging (exactly one definition).
    val raw :: OptionType;
    ## A type whose values are themselves option types.
    val optionType :: OptionType;
    ## An enumeration type accepting one value from a given list.
    val enum :: [a] -> OptionType;
    ## Accepts null or a value of the given type.
    val nullOr :: OptionType -> OptionType;
    ## A list where all elements have the given type.
    val listOf :: OptionType -> OptionType;
    ## Like listOf but the merged list must contain at least one element.
    val nonEmptyListOf :: OptionType -> OptionType;
    ## An attribute set where all values have the given type.
    val attrsOf :: OptionType -> OptionType;
    ## Like attrsOf but lazy in its values.
    val lazyAttrsOf :: OptionType -> OptionType;
    ## A value that is either of type t1 or t2.
    val either :: OptionType -> OptionType -> OptionType;
    ## A value that matches one of the given types.
    val oneOf :: [OptionType] -> OptionType;
    ## Accepts fromType (coerced via function) or toType directly.
    val coercedTo :: OptionType -> (a -> b) -> OptionType -> OptionType;
    ## A function that returns a value of the given type.
    val functionTo :: OptionType -> OptionType;
    ## Defines a set of sub-options handled like a separate module.
    val submodule :: ({ ... } | ({ ... } -> { ... })) -> OptionType;
    ## Like submodule but with more options (modules, specialArgs, etc.).
    val submoduleWith :: { ... } -> OptionType;
    ## A module that is not yet evaluated (deferred for later composition).
    val deferredModule :: OptionType;
    ## Like deferredModule but accepts statically known modules.
    val deferredModuleWith :: { ... } -> OptionType;
    ## A tagged union type where each attribute represents a variant.
    val attrTag :: { ... } -> OptionType;
    ## Wraps a type to prevent merging (error on multiple definitions).
    val uniq :: OptionType -> OptionType;
    ## Like uniq but allows multiple definitions if they are all equal.
    val unique :: { ... } -> OptionType -> OptionType;
    ## Extends a type with an additional validation check function.
    val addCheck :: OptionType -> (a -> bool) -> OptionType;
    ## Creates a custom option type.
    val mkOptionType :: { ... } -> OptionType;
    ## A string that must match the given regular expression.
    val strMatching :: string -> OptionType;
    ## A string type where definitions are merged with the given separator.
    val separatedString :: string -> OptionType;
    ## Wraps a type to ensure values are safe for /etc/passwd format.
    val passwdEntry :: OptionType -> OptionType;
    ## A TCP/UDP port number (0 to 65535).
    val port :: OptionType;

    module ints {
      ## A positive integer (> 0).
      val positive :: OptionType;
      ## An unsigned integer (>= 0).
      val unsigned :: OptionType;
      ## An integer in a specified inclusive range.
      val between :: int -> int -> OptionType;
      ## A signed 8-bit integer (-128 to 127).
      val s8 :: OptionType;
      ## A signed 16-bit integer (-32768 to 32767).
      val s16 :: OptionType;
      ## A signed 32-bit integer.
      val s32 :: OptionType;
      ## An unsigned 8-bit integer (0 to 255).
      val u8 :: OptionType;
      ## An unsigned 16-bit integer (0 to 65535).
      val u16 :: OptionType;
      ## An unsigned 32-bit integer.
      val u32 :: OptionType;
    }
  }

  # Re-exports — nixpkgs lib re-exports submodule functions at the top level
  val addContextFrom :: string -> string -> string;
  val all :: (a -> bool) -> [a] -> bool;
  val allUnique :: [a] -> bool;
  val any :: (a -> bool) -> [a] -> bool;
  val assertMsg :: bool -> string -> bool;
  val assertOneOf :: string -> a -> [a] -> bool;
  val attrByPath :: [string] -> Any -> { ... } -> Any;
  val attrNames :: { ... } -> [string];
  val attrVals :: [string] -> { ... } -> [Any];
  val attrValues :: { ... } -> [Any];
  val boolToString :: bool -> string;
  val boolToYesNo :: bool -> string;
  val callPackageWith :: { ... } -> (({ ... } -> a) | path) -> { ... } -> a;
  val callPackagesWith :: { ... } -> (({ ... } -> { ... }) | path) -> { ... } -> { ... };
  val cartesianProduct :: { ... } -> [{ ... }];
  val catAttrs :: string -> [{ ... }] -> [Any];
  val checkListOfEnum :: string -> [a] -> [a] -> a -> a;
  val chooseDevOutputs :: [Derivation] -> [Derivation];
  val cmakeBool :: string -> bool -> string;
  val cmakeFeature :: string -> string -> string;
  val cmakeOptionType :: string -> string -> string -> string;
  val collect :: ({ ... } -> bool) -> { ... } -> [x];
  val concat :: [a] -> [a] -> [a];
  val concatImapStrings :: (int -> a -> string) -> [a] -> string;
  val concatImapStringsSep :: string -> (int -> a -> string) -> [a] -> string;
  val concatLines :: [string] -> string;
  val concatLists :: [[a]] -> [a];
  val concatMap :: (a -> [b]) -> [a] -> [b];
  val concatMapAttrs :: (string -> a -> { ... }) -> { ... } -> { ... };
  val concatMapAttrsStringSep :: string -> (string -> Any -> string) -> { ... } -> string;
  val concatMapStrings :: (a -> string) -> [a] -> string;
  val concatMapStringsSep :: string -> (a -> string) -> [a] -> string;
  val concatStrings :: [string] -> string;
  val concatStringsSep :: string -> [string] -> string;
  val const :: a -> b -> a;
  val converge :: (a -> a) -> a -> a;
  val count :: (a -> bool) -> [a] -> int;
  val dontRecurseIntoAttrs :: { ... } -> { ... };
  val drop :: int -> [a] -> [a];
  val dropEnd :: int -> [a] -> [a];
  val elem :: a -> [a] -> bool;
  val enableFeature :: bool -> string -> string;
  val enableFeatureAs :: bool -> string -> string -> string;
  val escape :: [string] -> string -> string;
  val escapeRegex :: string -> string;
  val escapeShellArg :: string -> string;
  val escapeShellArgs :: [string] -> string;
  val escapeURL :: string -> string;
  val escapeXML :: string -> string;
  val evalModules :: { ... } -> { ... };
  val extendDerivation :: bool -> Any -> Derivation -> Derivation;
  val fileContents :: path -> string;
  val filter :: (a -> bool) -> [a] -> [a];
  val filterAttrs :: (string -> Any -> bool) -> { ... } -> { ... };
  val filterAttrsRecursive :: (string -> Any -> bool) -> { ... } -> { ... };
  val findFirst :: (a -> bool) -> b -> [a] -> (a | b);
  val findSingle :: (a -> bool) -> a -> a -> [a] -> a;
  val fix :: (a -> a) -> a;
  val fixedWidthNumber :: int -> int -> string;
  val fixedWidthString :: int -> string -> string -> string;
  val flatten :: [[a]] -> [a];
  val flip :: (a -> b -> c) -> (b -> a -> c);
  val foldAttrs :: (Any -> Any -> Any) -> Any -> [{ ... }] -> Any;
  val foldl :: (b -> a -> b) -> b -> [a] -> b;
  val foldlAttrs :: ( a -> string -> b -> a ) -> a -> { _: b, ... } -> a;
  val forEach :: [a] -> (a -> b) -> [b];
  val fromHexString :: string -> int;
  val functionArgs :: (a -> b) -> { _: bool, ... };
  val genAttrs :: [ string ] -> (string -> Any) -> { ... };
  val getAttr :: string -> { _: a, ... } -> a;
  val getAttrFromPath :: [string] -> { ... } -> Any;
  val getAttrs :: [string] -> { ... } -> { ... };
  val getBin :: Derivation -> Derivation;
  val getDev :: Derivation -> Derivation;
  val getExe :: Derivation -> string;
  val getFirstOutput :: [string] -> Derivation -> Derivation;
  val getInclude :: Derivation -> Derivation;
  val getLib :: Derivation -> Derivation;
  val getMan :: Derivation -> Derivation;
  val getName :: string | Derivation -> string;
  val getStatic :: Derivation -> Derivation;
  val getVersion :: string | Derivation -> string;
  val groupBy :: (a -> string) -> [a] -> { _: [a], ... };
  val hasAttr :: string -> { ... } -> bool;
  val hasAttrByPath :: [string] -> { ... } -> bool;
  val hasInfix :: string -> string -> bool;
  val hasPrefix :: string -> string -> bool;
  val hasSuffix :: string -> string -> bool;
  val head :: [a] -> a;
  val hydraJob :: (Derivation | null) -> (Derivation | null);
  val id :: a -> a;
  val ifilter0 :: (int -> a -> bool) -> [a] -> [a];
  val imap :: (int -> a -> b) -> [a] -> [b];
  val imap0 :: (int -> a -> b) -> [a] -> [b];
  val imap1 :: (int -> a -> b) -> [a] -> [b];
  val importJSON :: path -> a;
  val importTOML :: path -> a;
  val init :: [a] -> [a];
  val intersectLists :: [a] -> [a] -> [a];
  val intersperse :: a -> [a] -> [a];
  val isAttrs :: a -> bool;
  val isDerivation :: Any -> bool;
  val isOption :: a -> bool;
  val isStorePath :: a -> bool;
  val isStringLike :: a -> bool;
  val isValidPosixName :: string -> bool;
  val join :: string -> [string] -> string;
  val last :: [a] -> a;
  val length :: [a] -> int;
  val listToAttrs :: [{ name: string, value: a }] -> { _: a, ... };
  val literalExpression :: string -> { ... };
  val literalMD :: string -> { ... };
  val makeBinPath :: [Derivation] -> string;
  val makeIncludePath :: [Derivation] -> string;
  val makeLibraryPath :: [Derivation] -> string;
  val makeOverridable :: ({ ... } -> a) -> { ... } -> a;
  val makeSearchPath :: string -> [string] -> string;
  val makeSearchPathOutput :: string -> string -> [Derivation] -> string;
  val map :: (a -> b) -> [a] -> [b];
  val mapAttrs :: (string -> Any -> Any) -> { ... } -> { ... };
  val mapAttrsRecursive :: ([string] -> a -> b) -> { ... } -> { ... };
  val mapAttrsRecursiveCond :: ({ ... } -> bool) -> ([string] -> a -> b) -> { ... } -> { ... };
  val mapAttrsToList :: (string -> a -> b) -> { ... } -> [b];
  val mapAttrsToListRecursive :: ([string] -> a -> b) -> { ... } -> [b];
  val mapAttrsToListRecursiveCond :: ([string] -> { ... } -> bool) -> ([string] -> a -> b) -> { ... } -> [b];
  val mapCartesianProduct :: ({ ... } -> a) -> { ... } -> [a];
  val mapCrossIndex :: (a -> b) -> { ... } -> { ... };
  val matchAttrs :: { ... } -> { ... } -> bool;
  val mergeAttrs :: { ... } -> { ... } -> { ... };
  val mergeAttrsList :: [ { ... } ] -> { ... };
  val mesonBool :: string -> bool -> string;
  val mesonEnable :: string -> bool -> string;
  val mesonOption :: string -> string -> string;
  val mirrorFunctionArgs :: (a -> b) -> (a -> c) -> (a -> c);
  val mkAfter :: a -> a;
  val mkAliasOptionModule :: [string] -> [string] -> { ... };
  val mkBefore :: a -> a;
  val mkDefault :: a -> a;
  val mkEUI64Suffix :: string -> string;
  val mkEnableOption :: string -> { ... };
  val mkFixStrictness :: a -> a;
  val mkForce :: a -> a;
  val mkIf :: bool -> a -> a;
  val mkLuaInline :: string -> { ... };
  val mkMerge :: [a] -> a;
  val mkOption :: { ... } -> { ... };
  val mkOptionDefault :: a -> a;
  val mkOrder :: int -> a -> a;
  val mkOverride :: int -> a -> a;
  val mkPackageOption :: { ... } -> (string | [string]) -> { ... } -> { ... };
  val mkRemovedOptionModule :: [string] -> string -> { ... };
  val mkRenamedOptionModule :: [string] -> [string] -> { ... };
  val mkSinkUndeclaredOptions :: { ... } -> { ... };
  val nameFromURL :: string -> string;
  val naturalSort :: [string] -> [string];
  val optional :: bool -> a -> [a];
  val optionalAttrs :: bool -> { ... } -> { ... };
  val optionalDrvAttr :: bool -> a -> a | null;
  val optionalString :: bool -> string -> string;
  val optionals :: bool -> [a] -> [a];
  val overrideDerivation :: Derivation -> ( Derivation -> { ... } ) -> Derivation;
  val overrideExisting :: { ... } -> { ... } -> { ... };
  val pathIsDirectory :: path -> bool;
  val pathIsRegularFile :: path -> bool;
  val pathType :: path -> string;
  val range :: int -> int -> [int];
  val readFileType :: path -> string;
  val recurseIntoAttrs :: { ... } -> { ... };
  val recursiveUpdate :: { ... } -> { ... } -> { ... };
  val recursiveUpdateUntil :: ( [ string ] -> { ... } -> { ... } -> bool ) -> { ... } -> { ... } -> { ... };
  val remove :: a -> [a] -> [a];
  val removePrefix :: string -> string -> string;
  val removeSuffix :: string -> string -> string;
  val renameCrossIndexFrom :: string -> { ... } -> { ... };
  val renameCrossIndexTo :: string -> { ... } -> { ... };
  val replaceString :: string -> string -> string -> string;
  val replaceStrings :: [string] -> [string] -> string -> string;
  val replicate :: int -> a -> [a];
  val reverseList :: [a] -> [a];
  val setAttrByPath :: [string] -> Any -> { ... };
  val setFunctionArgs :: (a -> b) -> { _: bool, ... } -> (a -> b);
  val showAttrPath :: [string] -> string;
  val showOption :: [string] -> string;
  val singleton :: a -> [a];
  val sort :: (a -> a -> bool) -> [a] -> [a];
  val sourceFilesBySuffices :: a -> [string] -> a;
  val splitByAndCompare :: (a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int);
  val splitString :: string -> string -> [string];
  val splitStringBy :: (string -> string -> bool) -> bool -> string -> [string];
  val stringAsChars :: (string -> string) -> string -> string;
  val stringToCharacters :: string -> [string];
  val sublist :: int -> int -> [a] -> [a];
  val subtractLists :: [a] -> [a] -> [a];
  val tail :: [a] -> [a];
  val take :: int -> [a] -> [a];
  val takeEnd :: int -> [a] -> [a];
  val throwIf :: bool -> string -> a -> a;
  val throwIfNot :: bool -> string -> a -> a;
  val toCamelCase :: string -> string;
  val toDerivation :: path -> Derivation;
  val toInt :: string -> int;
  val toIntBase10 :: string -> int;
  val toLower :: string -> string;
  val toSentenceCase :: string -> string;
  val toUpper :: string -> string;
  val traceIf :: bool -> string -> a -> a;
  val traceSeq :: a -> b -> b;
  val traceSeqN :: int -> a -> b -> b;
  val traceVal :: a -> a;
  val traceValFn :: (a -> b) -> a -> a;
  val trim :: string -> string;
  val unique :: [a] -> [a];
  val uniqueStrings :: [ string ] -> [ string ];
  val versionAtLeast :: string -> string -> bool;
  val versionOlder :: string -> string -> bool;
  val warn :: string -> a -> a;
  val warnIf :: bool -> string -> a -> a;
  val warnIfNot :: bool -> string -> a -> a;
  val withFeature :: bool -> string -> string;
  val withFeatureAs :: bool -> string -> string -> string;
  val zipAttrs :: [ { ... } ] -> { ... };
  val zipAttrsWith :: (string -> [ Any ] -> Any) -> [ { ... } ] -> { ... };
  val zipAttrsWithNames :: [ string ] -> (string -> [ Any ] -> Any) -> [ { ... } ] -> { ... };
  val zipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c];
}

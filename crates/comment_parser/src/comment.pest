WHITESPACE     = _{ " " | "\t" }
NEWLINE        = _{ "\r\n" | "\n" }
ANY_WHITESPACE = _{ WHITESPACE | NEWLINE }

comment_content = {
    SOI ~ (type_block | other_text)* ~ EOI
}

// Two trigger formats:
// 1. "type:" prefix (tix-native): unfenced or fenced
// 2. "# Type" markdown heading (nixpkgs/typednix convention): always fenced
type_block = {
    "type:" ~ (WHITESPACE | NEWLINE)*
  ~ ("```" ~ block_content ~ "```" // triple-tick-fenced
  | block_content // free-text (unfenced)
  )
  | "#" ~ "Type" ~ NEWLINE ~ (WHITESPACE | NEWLINE)*
  ~ "```" ~ block_content ~ "```"
}

// Everything else that's not a `type_block`.
other_text = _{ (!type_block ~ ANY)+ }

// -------------------------------------------------------------------------
// The unified content rule for types
// -------------------------------------------------------------------------
block_content = {
    (ANY_WHITESPACE)* ~ (type_line)+ ~ (ANY_WHITESPACE)*
}

// A “type line” is `identifier :: type_expr`, e.g. `mapMe :: [a] -> (a -> b) -> [b]`.
type_line = {
    (ANY_WHITESPACE)* ~ identifier ~ "::" ~ type_expr ~ (NEWLINE | EOI)
}

// Identifiers: allow alphanumeric plus underscores
identifier = @{
    ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*
}

// A minimal arrow-based type expression, e.g. `Int -> String`, `[a] -> (a -> b) -> [b]`.
// Precedence (lowest to highest): `->` > `|` > `&` > atoms.
type_expr = {
    arrow_segment ~ ("->" ~ arrow_segment)*
}

// One segment in an arrow chain. Union has lower precedence than intersection.
arrow_segment = { union_type }

// Union type: `int | string | null`
union_type = { isect_type ~ ("|" ~ isect_type)* }

// Intersection type: `{ foo: int } & { bar: string }`
isect_type = { atom_type ~ ("&" ~ atom_type)* }

// Atoms: parenthesized, list, attrset, or a simple/base type reference.
atom_type = { paren_type | list_type | attrset_type | type_ref }

// Attrset type: `{ name: string, age: int }` or `{ name: string, ... }` or `{ _: int }`.
// Bodies must be single-line since WHITESPACE only covers " " | "\t" in this grammar.
attrset_type = { "{" ~ attrset_inner ~ "}" }
attrset_inner = _{
    open_marker
  | dyn_field ~ ("," ~ open_marker)? ~ ","?
  | named_field ~ ("," ~ named_field)* ~ ("," ~ (dyn_field ~ ("," ~ open_marker)? | open_marker))? ~ ","?
}
named_field = { identifier ~ ":" ~ type_expr }
dyn_field = { "_" ~ ":" ~ type_expr }
open_marker = { "..." }

paren_type = {
    "(" ~ type_expr ~ ")"
}

list_type = {
    "[" ~ type_expr ~ "]"
}

// a type var or reference to another type
type_ref = {
    primitive_ref
  | user_type
  | generic_ident
}

// generic params are lowercased
generic_ident = @{
    ASCII_ALPHA_LOWER ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")*
}

// a reference to some user type alias must be uppercase
user_type = @{
    ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")*
}

primitive_ref = {
    string_ref
  | number_ref
  | int_ref
  | bool_ref
  | float_ref
  | path_ref
  | null_ref
}

// TODO: not sure if these should be uppercase
// typescript does these as lowercase but since we have implicit generics as lowercase
// maybe making them uppercase is fine?
// the only reservation I have now is that nixpkgs lib does these are lowercase
string_ref = @{ "string" }
number_ref = @{ "number" }
int_ref    = @{ "int" }
bool_ref   = @{ "bool" }
float_ref  = @{ "float" }
path_ref   = @{ "path" }
null_ref   = @{ "null" }

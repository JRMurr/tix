// =============================================================================
// .tix declaration file grammar
// =============================================================================
//
// Separate grammar from comment.pest because .tix files need newlines as
// whitespace (multi-line type bodies), whereas doc comment parsing needs
// newlines as terminators.

WHITESPACE = _{ " " | "\t" | "\r\n" | "\n" }

// Regular comments start with `#` but NOT `##` (which are doc comments).
COMMENT    = _{ !("##") ~ "#" ~ (!"\n" ~ ANY)* }

// =============================================================================
// Doc comments
// =============================================================================
//
// `##` lines are doc comments that attach to the next declaration or field.
// Multiple consecutive `##` lines form a doc block. The `## ` prefix (with
// trailing space) is stripped during collection; bare `##` lines become empty.

doc_comment = @{ "##" ~ (!"\n" ~ ANY)* }
doc_block   = { doc_comment+ }

// Entry point
tix_file = { SOI ~ tix_declaration* ~ EOI }

tix_declaration = _{ type_alias_decl | val_decl | module_decl }

type_alias_decl = { doc_block? ~ "type" ~ user_type ~ "=" ~ type_expr ~ ";" }
val_decl        = { doc_block? ~ "val" ~ identifier ~ "::" ~ type_expr ~ ";" }
module_decl     = { doc_block? ~ "module" ~ identifier ~ "{" ~ tix_declaration* ~ "}" }

// -------------------------------------------------------------------------
// Type expressions (duplicated from comment.pest to keep grammars decoupled)
// -------------------------------------------------------------------------

type_expr     = { arrow_segment ~ ("->" ~ arrow_segment)* }
arrow_segment = { union_type }
union_type    = { isect_type ~ ("|" ~ isect_type)* }
isect_type    = { atom_type ~ ("&" ~ atom_type)* }
atom_type     = { paren_type | list_type | attrset_type | type_ref }

paren_type = { "(" ~ type_expr ~ ")" }
list_type  = { "[" ~ type_expr ~ "]" }

// Attrset types â€” same rules as comment.pest Phase 1.
attrset_type = { "{" ~ attrset_inner ~ "}" }
attrset_inner = _{
    open_marker
  | dyn_field ~ ("," ~ open_marker)? ~ ","?
  | named_field ~ ("," ~ named_field)* ~ ("," ~ (dyn_field ~ ("," ~ open_marker)? | open_marker))? ~ ","?
}
named_field = { doc_block? ~ field_name ~ optional_marker? ~ ":" ~ type_expr }
optional_marker = { "?" }
field_name = _{ quoted_field | identifier }
// Quoted identifiers for field names containing dots or other special characters
// (e.g. NixOS sysctl keys like "net.core.rmem_max").
quoted_field = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
dyn_field   = { "_" ~ ":" ~ type_expr }
open_marker = { "..." }

// Type references
type_ref = {
    primitive_ref
  | any_ref
  | never_ref
  | user_type
  | generic_ident
}

generic_ident = @{
    ASCII_ALPHA_LOWER ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")*
}

user_type = @{
    ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")*
}

// Nix attribute names can be arbitrary strings, so identifiers in .tix files
// need broad coverage. Allows: letters, digits, underscores, hyphens, apostrophes.
// Leading digits are fine in field position (e.g. `2bwm: { ... }`) since the
// colon disambiguates from number literals.
// Bare `_` is reserved for dyn_field, so underscore-led names need a continuation.
identifier = @{
    ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "'" | "-")*
  | "_" ~ (ASCII_ALPHANUMERIC | "_" | "'" | "-")+
  | ASCII_DIGIT ~ (ASCII_ALPHANUMERIC | "_" | "'" | "-")*
}

primitive_ref = {
    string_ref
  | number_ref
  | int_ref
  | bool_ref
  | float_ref
  | path_ref
  | null_ref
}

string_ref = @{ "string" }
number_ref = @{ "number" }
int_ref    = @{ "int" }
bool_ref   = @{ "bool" }
float_ref  = @{ "float" }
path_ref   = @{ "path" }
null_ref   = @{ "null" }

// Top and bottom types
any_ref   = @{ "any" }
never_ref = @{ "never" }
